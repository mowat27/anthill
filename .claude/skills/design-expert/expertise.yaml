# Anthill Framework - Design Expertise
# Mental model for the anthill workflow engine
# Last validated: 2026-02-07

overview:
  name: anthill
  purpose: >
    Lightweight Python workflow engine. Users define handlers (workflow steps)
    via a decorator-based App, wire them to a Channel (I/O boundary), and
    execute through a Runner. Designed for composable, testable pipelines.
  python: ">=3.12"
  build: uv (uv_build backend)
  entry_point: "anthill.cli:main"
  quality_tools:
    - ruff (lint)
    - ty (type-check)
    - pytest (test)
  justfile_default: "check -> ruff, ty, test"

architecture:
  core_pattern: >
    Reducer pattern. Each workflow step receives (runner, state) and returns
    a new State dict. run_workflow folds state through a list of steps.
    State is ephemeral and never shared between workflow runs — this ensures
    thread safety (one App serves multiple concurrent workflows) and makes
    reasoning straightforward.
  layer_rules:
    - "Outer layers (channels, CLI) depend on inner layers (core). Never the reverse."
    - "Core must be truly generic — no channel-specific or domain-specific concepts."
    - "Channels own runtime type/value checks to prevent bad data reaching core."
    - "Errors generally propagate up to handlers: missing keys, failed connections, naming mistakes."
    - "Edge validation (e.g. missing CLI params) can be handled and reported only when a stack trace adds no value."
  layers:
    - name: core
      path: src/anthill/core/
      responsibility: >
        Framework kernel. Contains domain types, the App handler registry,
        the Runner execution engine, and the run_workflow composition helper.
      modules:
        - domain.py
        - app.py
        - runner.py

    - name: channels
      path: src/anthill/channels/
      responsibility: >
        I/O boundary adapters. Each channel satisfies the Channel protocol
        and owns how progress/errors are reported and what initial state is
        supplied. Channels are the seam where tests swap in doubles.
      modules:
        - cli.py

    - name: llm
      path: src/anthill/llm/
      responsibility: >
        LLM agent abstraction layer. Defines the Agent protocol for LLM
        interactions and provides concrete implementations (ClaudeCodeAgent).
        Handlers use agents to delegate prompts to external LLM tooling.
      modules:
        - __init__.py   # Agent protocol
        - errors.py     # AgentExecutionError
        - claude_code.py  # ClaudeCodeAgent (subprocess-based)

    - name: helpers
      path: src/anthill/helpers/
      responsibility: >
        Shared utility functions. Currently contains JSON extraction for
        parsing LLM responses that embed JSON in markdown or prose.
      modules:
        - json.py  # extract_json — finds first {…} in text, parses as JSON

    - name: cli
      path: src/anthill/cli.py
      responsibility: >
        Argparse-based CLI entry point. Loads a user-supplied agents file
        (Python module exporting `app`), builds a CliChannel, and runs
        the workflow via Runner.

  logging: >
    File-based per-run logging via Python stdlib logging. Runner creates a
    per-run logger (anthill.run.<id>) writing to <app.log_dir>/<timestamp>-<id>.log.
    Module-level loggers exist in cli.py, channels/cli.py, and llm/claude_code.py
    for debug tracing. No console logging by default — all framework logs go to files.

domain_types:
  State:
    file: src/anthill/core/domain.py
    definition: "type State = dict[str, Any]"
    notes: >
      Type alias. All workflow state is a flat string-keyed dict. Handlers
      receive and return State; Runner injects run_id and workflow_name.

  Channel:
    file: src/anthill/core/domain.py
    definition: Protocol
    attributes:
      - "type: str"
      - "workflow_name: str"
      - "initial_state: State"
    methods:
      - "report_progress(run_id: str, message: str, **opts: Any) -> None"
      - "report_error(run_id: str, message: str) -> None"
    notes: >
      Structural (duck-typed) protocol. Any object with these attrs/methods
      qualifies. This is the primary extension point for new I/O adapters.

core_objects:
  App:
    file: src/anthill/core/app.py
    responsibility: Handler registry keyed by function name.
    construction: "App(log_dir: str = 'agents/logs/')"
    attributes:
      - "handlers: dict  # name -> fn mapping"
      - "log_dir: str  # directory for per-run log files"
    interface:
      - "handler(fn) -> wrapper  # decorator that registers fn by fn.__name__"
      - "get_handler(name) -> Callable[[Runner, State], State | NoReturn]"
    design_constraint: >
      get_handler raises ValueError for unknown names. The decorator stores
      the original fn (not the wrapper) in self.handlers. log_dir is passed
      to Runner for per-run file logging.

  Runner:
    file: src/anthill/core/runner.py
    responsibility: >
      Execution engine. Binds an App + Channel, generates a run id, sets up
      per-run file logging, and drives the workflow lifecycle.
    construction: "Runner(app: App, channel: Channel)"
    attributes:
      - "id: str  # uuid4 hex[:8]"
      - "channel: Channel"
      - "app: App"
      - "logger: logging.Logger  # per-run file logger (anthill.run.<id>)"
    interface:
      - "run() -> State  # merges channel.initial_state with run_id/workflow_name, calls workflow"
      - "workflow_name: property  # delegates to channel.workflow_name"
      - "workflow: property  # resolves handler via app.get_handler(workflow_name)"
      - "report_progress(message) -> None  # logs then delegates to channel"
      - "report_error(message) -> None  # logs then delegates to channel"
      - "fail(message) -> NoReturn  # logs, prints to stderr, exits(1)"
    design_constraint: >
      Runner.__init__ creates log dir (app.log_dir), sets up a FileHandler
      writing to <log_dir>/<YYYYMMDDHHMMSS>-<id>.log. Logger propagate=False
      to avoid console output. run() wraps workflow call in try/except to log
      errors before re-raising.

  run_workflow:
    file: src/anthill/core/app.py
    signature: "run_workflow(runner: Runner, state: State, steps: list[Callable]) -> State"
    responsibility: >
      Sequential composition helper. Folds state through a list of handler
      callables. Logs step names and completion via runner.logger.

llm_types:
  Agent:
    file: src/anthill/llm/__init__.py
    definition: Protocol
    methods:
      - "prompt(prompt: str) -> str"
    notes: >
      Structural protocol for LLM agents. Any object with a prompt() method
      qualifies. This is the extension point for adding new LLM backends.

  AgentExecutionError:
    file: src/anthill/llm/errors.py
    definition: "class AgentExecutionError(Exception)"
    notes: >
      Raised when an agent fails to execute a prompt (non-zero exit,
      missing binary, etc.).

  ClaudeCodeAgent:
    file: src/anthill/llm/claude_code.py
    satisfies: Agent protocol
    construction: "ClaudeCodeAgent(model: str | None = None)"
    behavior:
      prompt: >
        Runs `claude -p <prompt>` via subprocess. If model is set,
        inserts `--model <model>` flag. Returns stdout on success.
        Logs prompt submission, response, and errors via module logger.
      errors:
        - "Non-zero exit → AgentExecutionError with stderr"
        - "Missing binary → AgentExecutionError('claude binary not found')"

channel_implementations:
  CliChannel:
    file: src/anthill/channels/cli.py
    satisfies: Channel protocol
    construction: "CliChannel(workflow_name: str, initial_state: dict[str,str] | None = None)"
    behavior:
      type: '"cli"'
      initial_state: "Copies input dict or defaults to {}"
      report_progress: "Prints formatted [workflow_name, run_id] message to stdout"
      report_error: "Delegates to report_progress with file=sys.stderr"

cli_entry_point:
  file: src/anthill/cli.py
  subcommands:
    run:
      args:
        - "--agents-file (default: handlers.py) — path to Python module exporting `app`"
        - "--initial-state key=val (repeatable) — seed state pairs"
        - "--prompt — user prompt string, stored as state['prompt'] (mutually exclusive with --prompt-file)"
        - "--prompt-file — path to file whose contents become state['prompt'] (mutually exclusive with --prompt)"
        - "--model — model identifier, stored as state['model']"
        - "workflow_name (positional) — workflow name to invoke"
      mutual_exclusion: "--prompt and --prompt-file are in an argparse mutually exclusive group"
      flow: >
        1. load_app() dynamically imports the agents file via importlib
        2. parse_state_pairs() splits key=val strings into dict
        3. If --prompt provided, sets state['prompt'] to the string value
        4. If --prompt-file provided, reads file via Path.read_text() into state['prompt']
        5. Merges --model into state dict if provided
        6. Builds CliChannel with workflow_name, initial_state=dict
        7. Creates Runner(app, channel) and calls runner.run()
        8. Prints result dict to stdout
      error_handling:
        - "FileNotFoundError → agents file not found"
        - "AttributeError → agents file has no 'app'"
        - "FileNotFoundError → prompt file not found (--prompt-file)"
        - "Invalid state pair (no '=') → stderr + exit(1)"
  no_subcommand: "Prints help and exits 0"

data_flow:
  happy_path:
    - "CLI parses args → loads agents file → gets App"
    - "Builds CliChannel(workflow_name, initial_state)"
    - "Runner(app, channel).run() — creates log file, generates run id"
    - "Runner merges initial_state + {run_id, workflow_name}"
    - "Handler(runner, state) → new State"
    - "For composites: run_workflow folds state through sub-handlers"
    - "Result state printed to stdout"
  llm_path:
    - "Handler extracts prompt and model from state"
    - "Creates ClaudeCodeAgent(model=state.get('model'))"
    - "Calls agent.prompt('/<command> <prompt>')"
    - "Agent runs subprocess `claude -p` → stdout returned"
    - "Handler spreads state + {result: response}"
  error_path:
    - "Unknown handler → ValueError from App.get_handler"
    - "Handler calls runner.fail(msg) → logs, stderr, SystemExit(1)"
    - "Handler calls runner.report_error(msg) → logs, channel.report_error → stderr"
    - "Agent subprocess failure → AgentExecutionError propagates"
    - "Workflow exception → Runner logs error, re-raises"

testing_design:
  philosophy: >
    Test the framework, not app logic. Each test owns its setup. Replace
    I/O at the channel boundary with capturing doubles.
  test_channel:
    file: tests/conftest.py
    class: TestChannel
    satisfies: Channel protocol (duck-typed)
    captures:
      - "progress_messages: list[str]"
      - "error_messages: list[str]"
  fixtures:
    app:
      signature: "() -> App"
      notes: "Creates App with log_dir set to a tempfile.mkdtemp() directory"
    runner_factory:
      signature: "(test_app=None, workflow_name='test', initial_state=None) -> (Runner, TestChannel)"
      notes: "Uses injected app fixture by default; test_app overrides if provided"
  test_structure: >
    Tests organized into subdirectories mirroring src layout.
  test_files:
    - tests/core/test_workflows.py — core engine paths (single, multi-step, failure, unknown)
    - tests/core/test_logging.py — per-run file logging verification
    - tests/channels/test_cli_channel.py — CliChannel initial_state and attribute tests
    - tests/test_cli.py — CLI arg parsing, mutual exclusion, prompt-file loading, integration
    - tests/llm/test_claude_code_agent.py — ClaudeCodeAgent subprocess and error handling
    - tests/helpers/test_extract_json.py — JSON extraction from LLM responses

key_design_decisions:
  - >
    Channel is a Protocol, not an ABC. Extensions use structural subtyping.
  - >
    Handlers receive (runner, state) and return State. Runner is the only
    framework object a handler interacts with.
  - >
    State is always a new dict (spread pattern). No mutation of incoming state.
    State is ephemeral — never persisted or shared between workflow runs.
  - >
    run_workflow enables composition without inheritance or a DAG scheduler.
    Handlers that orchestrate other handlers just call run_workflow with a
    step list.
  - >
    The CLI dynamically loads user code via importlib. The agents file must
    export a module-level `app` object.
  - >
    Agent is a Protocol, like Channel. New LLM backends implement prompt(str)->str.
    ClaudeCodeAgent delegates to the `claude` CLI via subprocess.
  - >
    CLI passes --prompt (or --prompt-file) and --model into state dict.
    --prompt and --prompt-file are mutually exclusive; file contents are
    resolved in cli.py before reaching the channel. Handlers read from
    state, keeping the Runner/Channel layer unaware of LLM concerns.
  - >
    Errors propagate by default. Handler errors (missing keys), runtime issues
    (failed connections), and coding errors (naming mistakes) all propagate.
    Only edge validations (e.g. missing CLI params) are caught and reported
    when a stack trace would add no value.
  - >
    Per-run file logging. Each Runner creates an isolated log file. No console
    logging from the framework. Module-level loggers provide debug tracing.

# Anthill Framework - Design Expertise
# Mental model for the anthill workflow engine
# Last validated: 2026-02-07

overview:
  name: anthill
  purpose: >
    Lightweight Python workflow engine. Users define handlers (workflow steps)
    via a decorator-based App, wire them to a Channel (I/O boundary), and
    execute through a Runner. Designed for composable, testable pipelines.
  python: ">=3.12"
  build: uv (uv_build backend)
  entry_point: "anthill.cli:main"
  quality_tools:
    - ruff (lint)
    - ty (type-check)
    - pytest (test)
  justfile_default: "check -> ruff, ty, test"
  justfile_recipes:
    - "sdlc prompt model='opus' — runs sdlc workflow, auto-detects --prompt vs --prompt-file"
    - "sdlc_iso prompt model='opus' — runs sdlc_iso workflow (worktree-isolated), same prompt detection"

architecture:
  core_pattern: >
    Reducer pattern. Each workflow step receives (runner, state) and returns
    a new State dict. run_workflow folds state through a list of steps.
    State is ephemeral and never shared between workflow runs — this ensures
    thread safety (one App serves multiple concurrent workflows) and makes
    reasoning straightforward.
  layer_rules:
    - "Outer layers (channels, CLI) depend on inner layers (core). Never the reverse."
    - "Core must be truly generic — no channel-specific or domain-specific concepts."
    - "Channels own runtime type/value checks to prevent bad data reaching core."
    - "Errors generally propagate up to handlers: missing keys, failed connections, naming mistakes."
    - "Edge validation (e.g. missing CLI params) can be handled and reported only when a stack trace adds no value."
  layers:
    - name: core
      path: src/anthill/core/
      responsibility: >
        Framework kernel. Contains domain types, the App handler registry,
        the Runner execution engine, and the run_workflow composition helper.
      modules:
        - domain.py
        - app.py
        - runner.py

    - name: channels
      path: src/anthill/channels/
      responsibility: >
        I/O boundary adapters. Each channel satisfies the Channel protocol
        and owns how progress/errors are reported and what initial state is
        supplied. Channels are the seam where tests swap in doubles.
      modules:
        - cli.py

    - name: llm
      path: src/anthill/llm/
      responsibility: >
        LLM agent abstraction layer. Defines the Agent protocol for LLM
        interactions and provides concrete implementations (ClaudeCodeAgent).
        Handlers use agents to delegate prompts to external LLM tooling.
      modules:
        - __init__.py   # Agent protocol
        - errors.py     # AgentExecutionError
        - claude_code.py  # ClaudeCodeAgent (subprocess-based)

    - name: git
      path: src/anthill/git/
      responsibility: >
        Git integration layer. Provides worktree management for isolated
        workflow execution. Handlers use git worktrees to run SDLC steps
        in separate working directories without affecting the main checkout.
      modules:
        - __init__.py     # Re-exports Worktree, WorktreeError, git_worktree
        - worktrees.py    # Worktree class, WorktreeError, git_worktree context manager

    - name: helpers
      path: src/anthill/helpers/
      responsibility: >
        Shared utility functions. Currently contains JSON extraction for
        parsing LLM responses that embed JSON in markdown or prose.
      modules:
        - json.py  # extract_json — finds first {…} in text, parses as JSON

    - name: cli
      path: src/anthill/cli.py
      responsibility: >
        Argparse-based CLI entry point. Loads a user-supplied agents file
        (Python module exporting `app`), builds a CliChannel, and runs
        the workflow via Runner.

  logging: >
    File-based per-run logging via Python stdlib logging. Runner creates a
    per-run logger (anthill.run.<id>) writing to <app.log_dir>/<timestamp>-<id>.log.
    Module-level loggers exist in cli.py, channels/cli.py, llm/claude_code.py,
    and git/worktrees.py for debug tracing. No console logging by default —
    all framework logs go to files.

domain_types:
  State:
    file: src/anthill/core/domain.py
    definition: "type State = dict[str, Any]"
    notes: >
      Type alias. All workflow state is a flat string-keyed dict. Handlers
      receive and return State; Runner injects run_id and workflow_name.

  Channel:
    file: src/anthill/core/domain.py
    definition: Protocol
    attributes:
      - "type: str"
      - "workflow_name: str"
      - "initial_state: State"
    methods:
      - "report_progress(run_id: str, message: str, **opts: Any) -> None"
      - "report_error(run_id: str, message: str) -> None"
    notes: >
      Structural (duck-typed) protocol. Any object with these attrs/methods
      qualifies. This is the primary extension point for new I/O adapters.

core_objects:
  App:
    file: src/anthill/core/app.py
    responsibility: Handler registry keyed by function name.
    construction: "App(log_dir: str = 'agents/logs/', worktree_dir: str = 'trees/')"
    attributes:
      - "handlers: dict  # name -> fn mapping"
      - "log_dir: str  # directory for per-run log files"
      - "worktree_dir: str  # directory for git worktrees"
    interface:
      - "handler(fn) -> wrapper  # decorator that registers fn by fn.__name__"
      - "get_handler(name) -> Callable[[Runner, State], State | NoReturn]"
    design_constraint: >
      get_handler raises ValueError for unknown names. The decorator stores
      the original fn (not the wrapper) in self.handlers. log_dir is passed
      to Runner for per-run file logging. worktree_dir is used by handlers
      (e.g. sdlc_iso) to locate worktree base directories.

  Runner:
    file: src/anthill/core/runner.py
    responsibility: >
      Execution engine. Binds an App + Channel, generates a run id, sets up
      per-run file logging, and drives the workflow lifecycle.
    construction: "Runner(app: App, channel: Channel)"
    attributes:
      - "id: str  # uuid4 hex[:8]"
      - "channel: Channel"
      - "app: App"
      - "logger: logging.Logger  # per-run file logger (anthill.run.<id>)"
    interface:
      - "run() -> State  # merges channel.initial_state with run_id/workflow_name, calls workflow"
      - "workflow_name: property  # delegates to channel.workflow_name"
      - "workflow: property  # resolves handler via app.get_handler(workflow_name)"
      - "report_progress(message) -> None  # logs then delegates to channel"
      - "report_error(message) -> None  # logs then delegates to channel"
      - "fail(message) -> NoReturn  # logs, prints to stderr, exits(1)"
    design_constraint: >
      Runner.__init__ creates log dir (app.log_dir), sets up a FileHandler
      writing to <log_dir>/<YYYYMMDDHHMMSS>-<id>.log. Logger propagate=False
      to avoid console output. run() wraps workflow call in try/except to log
      errors before re-raising.

  run_workflow:
    file: src/anthill/core/app.py
    signature: "run_workflow(runner: Runner, state: State, steps: list[Callable]) -> State"
    responsibility: >
      Sequential composition helper. Folds state through a list of handler
      callables. Logs step names and completion via runner.logger.

git_objects:
  WorktreeError:
    file: src/anthill/git/worktrees.py
    definition: "class WorktreeError(Exception)"
    notes: >
      Raised when a git worktree operation fails (create, remove, or
      entering a non-existent worktree).

  Worktree:
    file: src/anthill/git/worktrees.py
    responsibility: >
      Represents a git worktree on disk. Wraps git worktree subprocess
      operations for creating and removing worktrees.
    construction: "Worktree(base_dir: str, name: str)"
    attributes:
      - "base_dir: str  # absolute path to the directory containing worktrees"
      - "name: str  # worktree subdirectory name"
      - "path: str  # absolute path (realpath of base_dir/name)"
    interface:
      - "exists: property -> bool  # checks os.path.isdir(self.path)"
      - "create(branch: str | None = None) -> None  # git worktree add, creates base_dir if needed"
      - "remove() -> None  # git worktree remove"
    design_constraint: >
      Paths are always resolved via os.path.realpath for consistency.
      create() uses os.makedirs(exist_ok=True) for the base directory.
      Both create() and remove() raise WorktreeError on non-zero git exit.
      Logging via module-level logger (anthill.git.worktrees).

  git_worktree:
    file: src/anthill/git/worktrees.py
    signature: "git_worktree(worktree, *, create=False, branch=None, remove=False) -> Generator[Worktree]"
    responsibility: >
      Context manager that enters a git worktree directory. Guarantees cwd
      restoration via try/finally. Optionally creates the worktree on entry
      and removes it on exit.
    behavior:
      entry: >
        If create=True, calls worktree.create(branch=branch). If create=False
        and worktree does not exist, raises WorktreeError. Saves current cwd
        and chdir to worktree.path.
      exit: >
        Restores original cwd (always, even on exception). If remove=True,
        calls worktree.remove() after restoring cwd.
      yields: "The Worktree instance that was entered."

llm_types:
  Agent:
    file: src/anthill/llm/__init__.py
    definition: Protocol
    methods:
      - "prompt(prompt: str) -> str"
    notes: >
      Structural protocol for LLM agents. Any object with a prompt() method
      qualifies. This is the extension point for adding new LLM backends.

  AgentExecutionError:
    file: src/anthill/llm/errors.py
    definition: "class AgentExecutionError(Exception)"
    notes: >
      Raised when an agent fails to execute a prompt (non-zero exit,
      missing binary, etc.).

  ClaudeCodeAgent:
    file: src/anthill/llm/claude_code.py
    satisfies: Agent protocol
    construction: "ClaudeCodeAgent(model: str | None = None)"
    behavior:
      prompt: >
        Runs `claude -p <prompt>` via subprocess. If model is set,
        inserts `--model <model>` flag. Returns stdout on success.
        Logs prompt submission, response, and errors via module logger.
      errors:
        - "Non-zero exit -> AgentExecutionError with stderr"
        - "Missing binary -> AgentExecutionError('claude binary not found')"

channel_implementations:
  CliChannel:
    file: src/anthill/channels/cli.py
    satisfies: Channel protocol
    construction: "CliChannel(workflow_name: str, initial_state: dict[str,str] | None = None)"
    behavior:
      type: '"cli"'
      initial_state: "Copies input dict or defaults to {}"
      report_progress: "Prints formatted [workflow_name, run_id] message to stdout"
      report_error: "Delegates to report_progress with file=sys.stderr"

cli_entry_point:
  file: src/anthill/cli.py
  subcommands:
    run:
      args:
        - "--agents-file (default: handlers.py) — path to Python module exporting `app`"
        - "--initial-state key=val (repeatable) — seed state pairs"
        - "--prompt — user prompt string, stored as state['prompt'] (mutually exclusive with --prompt-file)"
        - "--prompt-file — path to file whose contents become state['prompt'] (mutually exclusive with --prompt)"
        - "--model — model identifier, stored as state['model']"
        - "workflow_name (positional) — workflow name to invoke"
      mutual_exclusion: "--prompt and --prompt-file are in an argparse mutually exclusive group"
      flow: >
        1. load_app() dynamically imports the agents file via importlib
        2. parse_state_pairs() splits key=val strings into dict
        3. If --prompt provided, sets state['prompt'] to the string value
        4. If --prompt-file provided, reads file via Path.read_text() into state['prompt']
        5. Merges --model into state dict if provided
        6. Builds CliChannel with workflow_name, initial_state=dict
        7. Creates Runner(app, channel) and calls runner.run()
        8. Prints result dict to stdout
      error_handling:
        - "FileNotFoundError -> agents file not found"
        - "AttributeError -> agents file has no 'app'"
        - "FileNotFoundError -> prompt file not found (--prompt-file)"
        - "Invalid state pair (no '=') -> stderr + exit(1)"
  no_subcommand: "Prints help and exits 0"

handlers_file:
  file: handlers.py
  purpose: >
    Default user-land agents file exporting `app`. Contains LLM-backed
    workflow handlers that use ClaudeCodeAgent to run slash commands,
    extract structured JSON from responses, and thread results through state.
  app: "App()  # default log_dir and worktree_dir"
  code_organization: >
    File is structured in three sections, marked by comment headers:
    1. Steps (# --- Steps ---) — individual handler functions
    2. Shared workflow constants (# --- Shared workflow constants ---) —
       step lists shared by multiple workflows (e.g. SDLC_STEPS).
       Constants are only defined when shared; otherwise steps are inlined.
    3. Workflows (# --- Workflows ---) — composite handlers that call
       run_workflow or orchestrate steps.
  steps:
    specify:
      description: "Runs /specify, extracts spec_file and slug via extract_json"
      state_in: ["prompt", "model"]
      state_out: ["spec_file", "slug"]

    branch:
      description: "Runs /branch, extracts branch_name via extract_json"
      state_in: ["spec_file", "model"]
      state_out: ["branch_name"]

    implement:
      description: "Runs /implement against spec_file"
      state_in: ["spec_file", "model"]
      state_out: ["implement_status"]

    document:
      description: "Runs /document to update docs for current branch"
      state_in: ["model"]
      state_out: ["document_status"]

    derive_feature:
      description: "Runs /derive_feature, extracts feature_type and slug via extract_json"
      state_in: ["prompt", "model"]
      state_out: ["feature_type", "slug"]

  shared_constants:
    SDLC_STEPS: "[specify, branch, implement, document]  # used by sdlc and specify_and_branch"

  workflows:
    sdlc:
      description: "Composite workflow: specify -> branch -> implement -> document"
      steps: "run_workflow(runner, state, SDLC_STEPS)"

    specify_and_branch:
      description: "Partial SDLC: specify -> branch only"
      steps: "run_workflow(runner, state, SDLC_STEPS[0:2])"

    sdlc_iso:
      description: >
        Isolated SDLC workflow. Calls derive_feature to get feature_type
        and slug, creates a git worktree named {timestamp}-{run_id} on a
        branch {feature_type}/{slug}, runs specify -> implement -> document
        inside the worktree, then returns. Worktree is NOT removed on exit
        (remove=False). Steps are inlined as [specify, implement, document]
        (no shared constant — only used by this workflow).
      state_in: ["prompt", "model"]
      state_out: ["feature_type", "slug", "spec_file", "implement_status", "document_status", "worktree_path", "branch_name"]

data_flow:
  happy_path:
    - "CLI parses args -> loads agents file -> gets App"
    - "Builds CliChannel(workflow_name, initial_state)"
    - "Runner(app, channel).run() — creates log file, generates run id"
    - "Runner merges initial_state + {run_id, workflow_name}"
    - "Handler(runner, state) -> new State"
    - "For composites: run_workflow folds state through sub-handlers"
    - "Result state printed to stdout"
  llm_path:
    - "Handler extracts prompt and model from state"
    - "Creates ClaudeCodeAgent(model=state.get('model'))"
    - "Calls agent.prompt('/<command> <prompt>')"
    - "Agent runs subprocess `claude -p` -> stdout returned"
    - "Handler spreads state + {result: response}"
  worktree_iso_path:
    - "sdlc_iso calls derive_feature to get feature_type and slug"
    - "Creates Worktree(base_dir=runner.app.worktree_dir, name='{timestamp}-{run_id}')"
    - "Enters git_worktree(wt, create=True, branch='{feature_type}/{slug}', remove=False)"
    - "Inside worktree: runs specify -> implement -> document via run_workflow"
    - "On exit: cwd restored, worktree kept on disk for inspection"
    - "Returns state with worktree_path and branch_name added"
  error_path:
    - "Unknown handler -> ValueError from App.get_handler"
    - "Handler calls runner.fail(msg) -> logs, stderr, SystemExit(1)"
    - "Handler calls runner.report_error(msg) -> logs, channel.report_error -> stderr"
    - "Agent subprocess failure -> AgentExecutionError propagates"
    - "Workflow exception -> Runner logs error, re-raises"
    - "Worktree creation failure -> WorktreeError propagates"
    - "Entering non-existent worktree (create=False) -> WorktreeError"

testing_design:
  philosophy: >
    Test the framework, not app logic. Each test owns its setup. Replace
    I/O at the channel boundary with capturing doubles.
  test_channel:
    file: tests/conftest.py
    class: TestChannel
    satisfies: Channel protocol (duck-typed)
    captures:
      - "progress_messages: list[str]"
      - "error_messages: list[str]"
  fixtures:
    app:
      signature: "() -> App"
      notes: "Creates App with log_dir and worktree_dir both set to tempfile.mkdtemp() directories"
    runner_factory:
      signature: "(test_app=None, workflow_name='test', initial_state=None) -> (Runner, TestChannel)"
      notes: "Uses injected app fixture by default; test_app overrides if provided"
    git_repo:
      file: tests/git/conftest.py
      signature: "() -> str (yields repo path)"
      notes: >
        Creates a temporary git repo with init commit, sets cwd to repo dir.
        Restores original cwd on teardown. Used by all git integration tests.
  test_structure: >
    Tests organized into subdirectories mirroring src layout.
  test_files:
    - tests/core/test_workflows.py — core engine paths (single, multi-step, failure, unknown)
    - tests/core/test_logging.py — per-run file logging, App config (log_dir, worktree_dir defaults)
    - tests/channels/test_cli_channel.py — CliChannel initial_state and attribute tests
    - tests/test_cli.py — CLI arg parsing, mutual exclusion, prompt-file loading, integration
    - tests/llm/test_claude_code_agent.py — ClaudeCodeAgent subprocess and error handling
    - tests/helpers/test_extract_json.py — JSON extraction from LLM responses
    - tests/git/test_worktree.py — Worktree class (path, exists, create, create+branch, remove, errors)
    - tests/git/test_context.py — git_worktree context manager (create, cwd, yield, restore, remove)

key_design_decisions:
  - >
    Channel is a Protocol, not an ABC. Extensions use structural subtyping.
  - >
    Handlers receive (runner, state) and return State. Runner is the only
    framework object a handler interacts with.
  - >
    State is always a new dict (spread pattern). No mutation of incoming state.
    State is ephemeral — never persisted or shared between workflow runs.
  - >
    run_workflow enables composition without inheritance or a DAG scheduler.
    Handlers that orchestrate other handlers just call run_workflow with a
    step list.
  - >
    The CLI dynamically loads user code via importlib. The agents file must
    export a module-level `app` object.
  - >
    Agent is a Protocol, like Channel. New LLM backends implement prompt(str)->str.
    ClaudeCodeAgent delegates to the `claude` CLI via subprocess.
  - >
    CLI passes --prompt (or --prompt-file) and --model into state dict.
    --prompt and --prompt-file are mutually exclusive; file contents are
    resolved in cli.py before reaching the channel. Handlers read from
    state, keeping the Runner/Channel layer unaware of LLM concerns.
  - >
    Errors propagate by default. Handler errors (missing keys), runtime issues
    (failed connections), and coding errors (naming mistakes) all propagate.
    Only edge validations (e.g. missing CLI params) are caught and reported
    when a stack trace would add no value.
  - >
    Per-run file logging. Each Runner creates an isolated log file. No console
    logging from the framework. Module-level loggers provide debug tracing.
  - >
    Git worktree isolation. The sdlc_iso handler creates a git worktree for
    each run, branching on {feature_type}/{slug}. This enables parallel
    feature development without cwd or branch conflicts. Worktrees are kept
    after workflow completion (remove=False) so developers can inspect results.
    App.worktree_dir configures the base directory (default "trees/").
